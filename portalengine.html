
<!DOCTYPE html>
<html>
<head>
    <title>Portal/Sector Render</title>
    <script src="./util/util.js"></script>
    <script src="./math/Projection3d.js"></script>
    <script src="./math/Interpolator.js"></script>
    <script src="./math/Clip2d.js"></script>
    <script src="./util/MapLoader.js"></script>

</head>
<body>

<canvas id="screen" width="320" height="240"
        style="border:1px solid #000000; float: left">
</canvas>

<div id="status" style="float: left; margin: 5px; font-family: Arial; font-size: 14px">tests</div>

<button type="button" onclick="Initialise()" style="display:none">Import</button>

</body>
<script>

    var SCREEN_WIDTH = 640;
    var SCREEN_HEIGHT = 480;
    var SCREEN_FOV = 60;

    document.getElementById('screen').width = SCREEN_WIDTH;
    document.getElementById('screen').height = SCREEN_HEIGHT;

    var buffer = document.getElementById('screen');
    buffer.style.opacity = 1.0;
    var buffer_context = buffer.getContext('2d');
    //buffer_context.globalCompositeOperation = 'xor';
    var buffer_data = buffer_context.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    var fov = SCREEN_FOV;
    var vfov = deg(2 * Math.atan(Math.tan(rad(fov)/2) * (SCREEN_HEIGHT/SCREEN_WIDTH)));
    var projection_width = SCREEN_WIDTH;
    var projection_centre = projection_width / 2;
    var projection_height = SCREEN_HEIGHT;

    var focal_length = projection_centre / Math.tan(rad(fov/2));

    function PLAYER()
    {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.v = 0;
        this.height = 75;
        this.sector = 0;
    }

    var player  = new PLAYER();

    var Game = {};

    function Initialise()
    {
        Game.scene = new PerspectiveProjector(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_FOV);

        Game.map = new Map();
        Game.fps = 30;

        Game.map.load('./maps/alantest3.map', 0.025, function(){

            player.x = Game.map.player.start_x;
            player.y = Game.map.player.start_y;
            player.z = Game.map.sectors[Game.map.player.start_sector].floor_height + player.height;
            player.v = Game.map.player.start_ang;
            player.height = 25;
            player.sector = Game.map.player.start_sector;

            window.addEventListener('keyup', function(event) {Key.onKeyup(event);}, false);
            window.addEventListener('keydown', function(event) {Key.onKeydown(event);}, false);
            //window.addEventListener('keypress', function(event) {alert('wtf')}, false);

            Game.frameTimer = window.setInterval(Render, 1000 / Game.fps);

            Render();

        });

        Math.clamp = function(v, min, max) {
            return Math.min(Math.max(v, min), max);
        };

    }

    function Rotate2d(x, y, angle)
    {
        var rv = rad(angle);

        var s = Math.sin(rv);
        var c = Math.cos(rv);

        //var rx1 = x * Math.cos(rv) - y * Math.sin(rv);
        //var rz1 = y * Math.cos(rv) + x * Math.sin(rv);
        var rx = x * Math.sin(rv) - y * Math.cos(rv);
        var rz = x * Math.cos(rv) + y * Math.sin(rv);
        //var rx = x * c - y * s;
        //var rz = x * s + y * c;

        return {x: rx, z: rz};
    }

    function project_wall(sector_height, z)
    {
        var heightA = (sector_height / z) *  focal_length;
        var eyeHeight = player.height * 0.75;
        //var player_z = objectZ = 0;
        var base = (eyeHeight *2); // + player_z - objectZ) * 2;
        var horizonOffset = (heightA - Math.floor(base / z * focal_length)) / 2;
        var endA = parseInt((SCREEN_HEIGHT / 2 - horizonOffset) + heightA / 2);
        return {height: heightA, y_bottom: endA};
    }

    function cross(x1, y1, x2, y2)
    {
        return x1*y2 - y1*x2;
    }

    function intersect2(x1,y1, x2,y2, x3,y3, x4,y4)
    {
        var x = vxs(vxs(x1, y1, x2, y2),  (x1) - (x2), vxs(x3, y3, x4, y4), (x3) - (x4)) / vxs((x1) - (x2), (y1) - (y2), (x3) - (x4), (y3) - (y4));
        var y = vxs(vxs(x1, y1, x2, y2), (y1) - (y2), vxs(x3, y3, x4, y4), (y3) - (y4)) / vxs((x1) - (x2), (y1) - (y2), (x3) - (x4), (y3) - (y4));
        return {x: x, y: y};
;    }

    function intersect(x1, y1, x2, y2, x3, y3, x4, y4)
    {
        var x = cross(x1, y1, x2, y2);
        var y = cross(x3, y3, x4, y4);
        var det = cross(x1-x2, y1-y2, x3-x4, y3-y4);
        var cx = cross(x, x1-x2, y, x3-x4) / det;
        var cy = cross(x, y1-y2, y, y3-y4) / det;

        return {x: cx, y: cy};
    }

    function intersect_box(x0,y0, x1,y1, x2,y2, x3,y3)
    {
        return  (overlap(x0,x1,x2,x3) && overlap(y0,y1,y2,y3));
    }

    function overlap(a0,a1,b0,b1)
    {
        return (Math.min(a0,a1) <= Math.max(b0,b1) & Math.min(b0,b1) <= Math.max(a0,a1));
    }


    function point_side(px,py, x0,y0, x1,y1)
    {
        return vxs((x1)-(x0), (y1)-(y0), (px)-(x0), (py)-(y0));
    }

    function vxs(x0,y0, x1,y1)
    {
        return ((x0)*(y1) - (x1)*(y0));
    }

    function RenderSector(x_clip_start, x_clip_end, sectorId)
    {
        var sector = Game.map.sectors[sectorId];

        for (var p=0; p<sector.walls.length; p++)
        {
            var wall = sector.walls[p];

            var wall_colour = '#aaaaaa';
            if (wall.portalTo != -1) wall_colour = '#ff0000';

            var vx1 = Game.map.vertices[wall.p1].x, vy1 = Game.map.vertices[wall.p1].y;
            var vx2 = Game.map.vertices[wall.p2].x, vy2 = Game.map.vertices[wall.p2].y;

            vx1 -= player.x; vy1 -= player.y;
            vx2 -= player.x; vy2 -= player.y;

            var r1 = Rotate2d(vx1, vy1, player.v);
            var r2 = Rotate2d(vx2, vy2, player.v);

            var sheight = sector.height;

            // completely off player's fov, move to next...
            if (r1.z <=0 && r2.z <=0) continue;

            var cp1 = intersect2(r1.x, r1.z, r2.x, r2.z, -0.0001, 0.0001, -20, 5);
            var cp2 = intersect2(r1.x, r1.z, r2.x, r2.z,  0.0001, 0.0001, 20, 5);

            if (r1.z <= 0.0001)
            {
                if (cp1.y > 0) {
                    r1.x = cp1.x;
                    r1.z = cp1.y;
                } else {
                    r1.x = cp2.x;
                    r1.z = cp2.y;
                }
            }

            if (r2.z <= 0.0001)
            {
                if (cp1.y > 0) {
                    r2.x = cp1.x;
                    r2.z = cp1.y;
                } else {
                    r2.x = cp2.x;
                    r2.z = cp2.y;
                }
            }



            var rel_floor_height = sector.floor_height - player.z;
            var rel_ceil_height = sector.ceiling_height - player.z;

            // we = wall edge
            var we = Game.scene.getEdge(player, r1, r2, rel_floor_height, rel_ceil_height);

            if (we.x1 >= we.x2) continue; // wall is not facing us, don't draw
            if (we.x2 < x_clip_start || we.x1 > x_clip_end) continue;

            var next_rel_floor_height = 0;
            var next_rel_ceil_height = 0;

            if (wall.portalTo != -1)
            {
                var nextSector = Game.map.sectors[wall.portalTo];

                next_rel_floor_height = nextSector.floor_height - player.z;
                next_rel_ceil_height = nextSector.ceiling_height - player.z;

            }

            var pe = Game.scene.projectPortalSector(we, r1, r2, next_rel_floor_height, next_rel_ceil_height);

            //if (wall.portalTo != -1)
            //    line(we.x1, pe.y1a, we.x2, pe.y2a, '#000000');

            var isteps = (we.x2 - we.x1) + 1;

            var ix1 = Math.max(we.x1, x_clip_start);
            var ix2 = Math.min(we.x2, x_clip_end);

            var start_at = Math.abs(we.x1 - ix1);

            var ya_interp = new Interpolator(we.y1a, we.y2a, isteps, start_at);
            var yb_interp = new Interpolator(we.y1b, we.y2b, isteps, start_at);
            var next_ya_interp = new Interpolator(pe.y1a, pe.y2a, isteps, start_at);
            var next_yb_interp = new Interpolator(pe.y1b, pe.y2b, isteps, start_at);

            if (wall.portalTo >= 0){

                console.log("Thisfloor=", sector.floor_height, ' Nextfloor=',nextSector.floor_height);

            if (nextSector.floor_height < sector.floor_height) {

                line(we.x1, we.y1b, we.x2, we.y2b, '#000');

            }

                line (we.x1, we.y1a, we.x2, we.y2a, '#0f0');

                if (nextSector.ceiling_height < sector.ceiling_height)
                {
                    line (we.x1, pe.y1a, we.x2, pe.y2a, '#f0f');

                }
            }


            for (var x=ix1; x<=ix2; x++)
            {
                var ya = ya_interp.next();
                var yb = yb_interp.next();

                var cya = clamp(ya, vstart_top[x], vstart_bottom[x]);
                var cyb = clamp(yb, vstart_top[x], vstart_bottom[x]);

                //line(x, vstart_top[x], x, cya-1, '#00f');
                line(x, cyb+1, x, vstart_bottom[x], '#0ff');

                if (sectorId == 0)
                    wall_colour = '#f80';
                else  if (sectorId==1 )
                    wall_colour = '#09f';

                if (wall.portalTo >= 0 )
                {
                    var nya = next_ya_interp.next();
                    var nyb = next_yb_interp.next();
                    var cnya = clamp(nya, vstart_top[x], vstart_bottom[x]);
                    var cnyb = clamp(nyb, vstart_top[x], vstart_bottom[x]);

                    // then there is no bottom to the wall
                   // if (nextSector.floor_height >= sector.floor_height)
                     //   line(x, cya, x, cnya-1, '#f00');


                    vstart_top[x] = clamp(Math.max(cya,cnya), vstart_top[x], SCREEN_HEIGHT-1);
                    vstart_bottom[x] = clamp(Math.min(cyb, cnyb), 0, vstart_bottom[x]);

                   // line(x, cnyb+1, x, cyb, '#f00');



                } else {

                   line (x, clamp(ya, vstart_top[x], vstart_bottom[x]), x, clamp(yb, vstart_top[x], vstart_bottom[x]), wall_colour);

                    vstart_bottom[x] = clamp(Math.min(yb, cyb), 0, vstart_bottom[x]);

                }



            }

            if (ix2 >= ix1 && wall.portalTo != -1)
            {
               RenderSector(ix1, ix2, wall.portalTo);
            }





            /**
                 x1y1a ---- x2y2a   1 A       B
                  |           |
                  |           |
                 x1y1b ---- x2y2b   2
            **/


            //line(we.x1, we.y1a, we.x1, we.y1b, wall_colour);
            //line(we.x2, we.y2a, we.x2, we.y2b, wall_colour);

            //horz
            //line(we.x1, we.y1a, we.x2, we.y2a, wall_colour);
            //line(we.x1, we.y1b, we.x2, we.y2b, wall_colour);

            //vertical edge sides of wall


            /**
            if (1 == 0) {
                var x1 = (-r1.x / r1.z) * focal_length;
                var x2 = (-r2.x / r2.z) * focal_length;

                var w_width = (x2 - x1) + 1;

                var y_bottom = edge1.y_bottom;
                var dy_bottom = (edge2.y_bottom - edge1.y_bottom) / w_width;

                var w_height = edge1.height;
                var dw_height = (edge2.height - edge1.height) / w_width;

                for (var wx = x1; wx < w_width; wx++) {
                    y_bottom += dy_bottom;
                    w_height += dw_height;
                }
                line(x1, edge1.y_bottom - edge1.height, x2, edge2.y_bottom - edge2.height,wall_colour);
                line(x1, edge1.y_bottom, x2, edge2.y_bottom,wall_colour);

                line(x2, edge2.y_bottom - edge2.height, x2, edge2.y_bottom,wall_colour);
                line(x1, edge1.y_bottom - edge1.height, x1, edge1.y_bottom,wall_colour);


                ///** WIREFRAME MODE -

                var steps = x2-x1;
                var ytop1 = edge2.y_bottom - edge2.height;
                var ybot1 = edge2.y_bottom;

                var ytop2 = edge1.y_bottom - edge1.height;
                var ybot2 = edge1.y_bottom;

                var ytopinc = (ytop2 - ytop1) / steps;
                var ybotinc = (ybot2 - ybot1) / steps;

                var ys = ytop1, ye = ybot1;

                for (var x=x1; x<x2; x++)
                {
                    //line (x, ys, x, ye, wall_colour);

                    ys += ytopinc;
                    ye += ybotinc;
                }
            }
            **/


        }

    }

    var vstart_top = [], vstart_bottom = [];

    function prepareFrame ()
    {
        for (var t=0; t<SCREEN_WIDTH;t++) {
            vstart_bottom[t] = SCREEN_HEIGHT-1;
            vstart_top[t] = 0;
        }

        buffer_context.clearRect(0,0,buffer.width, buffer.height);

    }

    function Render()
    {
        prepareFrame();
        move();

        var sector = Game.map.sectors[player.sector];

        for (var s=0; s<sector.walls.length; s++)
        {
           // if (sector.walls[s].portalTo > -1) RenderSector2(sector.walls[s].portalTo);
        }

        RenderSector(0, SCREEN_WIDTH-1, player.sector);

        status();
    }

    var ldraw_buffer = [];


    function lineb(x1, y1, x2, y2, col)
    {
        if (!col) col = '#0000ff';
        var out_bounds = false;
        if (x1 < 0 || x2 < 0 || x1 >= SCREEN_WIDTH || x2 >= SCREEN_WIDTH) out_bounds = true;
        if (y1 < 0 || y2 < 0 || y1 >= SCREEN_HEIGHT || y2 >= SCREEN_HEIGHT) out_bounds = true;

        if (out_bounds)
        {
            var lc = Clip2d(x1, y1, x2, y2, 0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1);
            if (!lc.visible) return;

            x1 = lc.x1;
            y1 = lc.y1;
            x2 = lc.x2;
            y2 = lc.y2;

        }

        ldraw_buffer.push({x1:x1, y1:y1, x2:x2, y2:y2, col:col});
/*
        buffer_context.beginPath();
        buffer_context.moveTo(x1, y1);
        buffer_context.lineTo(x2, y2);
        buffer_context.lineWidth = 1;
        buffer_context.strokeStyle = col;
        buffer_context.stroke();*/
    }

    function line_flush()
    {


        if (ldraw_buffer.length  <1 ) return;

        for (var t=0; t<ldraw_buffer.length;t++)
        {
            setTimeout(function(){
                console.log(Date.now());
                /*
                var l = ldraw_buffer[0];
                var x1 = l.x1, y1 = l.y1;
                var x2 = l.x2, y2 = l.y2;
                var col = l.col;

                ldraw_buffer.splice(0,1);

                buffer_context.beginPath();
                buffer_context.moveTo(x1, y1);
                buffer_context.lineTo(x2, y2);
                buffer_context.lineWidth = 1;
                buffer_context.strokeStyle = col;
                buffer_context.stroke();*/

            }, 10)

        }

        ldraw_buffer = [];

    };

    function line(x1, y1, x2, y2, col)
    {
        if (!col) col = '#0000ff';
        var out_bounds = false;
        if (x1 < 0 || x2 < 0 || x1 >= SCREEN_WIDTH || x2 >= SCREEN_WIDTH) out_bounds = true;
        if (y1 < 0 || y2 < 0 || y1 >= SCREEN_HEIGHT || y2 >= SCREEN_HEIGHT) out_bounds = true;

        if (out_bounds)
        {
            var lc = Clip2d(x1, y1, x2, y2, 0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1);
            if (!lc.visible) return;

            x1 = lc.x1;
            y1 = lc.y1;
            x2 = lc.x2;
            y2 = lc.y2;

        }


        buffer_context.beginPath();
        buffer_context.moveTo(x1, y1);
        buffer_context.lineTo(x2, y2);
        buffer_context.lineWidth = 1;
        buffer_context.strokeStyle = col;
        buffer_context.stroke();
    }

    function clamp(value, min, max)
    {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }


    function get_centre_of_sector(sec)
    {
        var sector = map.sectors[sec];

        var pts = [];

        for (var v=0; v<sector.vertices.length-1; v++)
            pts.push({x: map.vertices[sector.vertices[v]].x, y: map.vertices[sector.vertices[v]].y});

        return get_polygon_centroid(pts);

    }

    function get_polygon_centroid(pts) {
        var twicearea=0,
                x=0, y=0,
                nPts = pts.length,
                p1, p2, f;
        for ( var i=0, j=nPts-1 ; i<nPts ; j=i++ ) {
            p1 = pts[i]; p2 = pts[j];
            f = p1.x*p2.y - p2.x*p1.y;
            twicearea += f;
            x += ( p1.x + p2.x ) * f;
            y += ( p1.y + p2.y ) * f;
        }
        f = twicearea * 3;
        return { x:x/f, y:y/f };
    }


    function status_clear()
    {
        document.getElementById("status").innerHTML = "";
    }
    function status_write(text)
    {
        document.getElementById("status").innerHTML += text+"<br/>";
    }
    function status()
    {
        status_clear();

        status_write("<b>Player</b>");
        status_write("X: "+player.x.toFixed(2)+", Y: "+player.y.toFixed(2)+", Z: "+player.z);
        status_write("Angle: "+player.v.toFixed(2));
        status_write("Sector: "+player.sector);

        var sector = Game.map.sectors[player.sector];

        var psec = "";
        for (var t=0; t<sector.walls.length; t++)
        {
            var p = sector.walls[t].portalTo;
            if (p != -1) psec += p+",";
        }

        status_write("Potential visible sectors: "+psec);

    }

    function move_player(dx, dy)
    {
        var px = player.x, py = player.y;

        var sector = Game.map.sectors[player.sector];

        for (var s=0; s<sector.walls.length; s++)
        {
            var wall = sector.walls[s];

            if (wall.portalTo >= 0)
            {
                if (intersect_box(px, py, px+dx, py+dy,
                                Game.map.vertices[wall.p1].x, Game.map.vertices[wall.p1].y,
                                Game.map.vertices[wall.p2].x, Game.map.vertices[wall.p2].y))
                {
                    if (point_side(px+dx, py+dy,
                                    Game.map.vertices[wall.p1].x, Game.map.vertices[wall.p1].y,
                                    Game.map.vertices[wall.p2].x, Game.map.vertices[wall.p2].y))
                    {
                        player.sector = wall.portalTo;
                        break;

                    }

                }
            }

        }

        player.x += dx;
        player.y += dy;

    }


    function move()
    {
        var dx = 0, dy = 0;
        var speed =10;
/*
        if (e.keyCode == 189) // '-'
            player.height -=2;

        if (e.keyCode == 187) // '='
            player.height += 2;
*/
        if (Key.isDown(Key.RIGHT))
        {
            player.v +=6;
            if (player.v > 359) player.v -= 360;
        }

        if (Key.isDown(Key.MINUS))
        {
            player.z -=50;
        }

        if (Key.isDown(Key.PLUS))
        {
            player.z +=50;
        }

        if (Key.isDown(Key.LEFT))
        {
            player.v -= 6;
            if (player.v < 0) player.v += 360;
        }

        if (Key.isDown(Key.UP))
        {
            var rads = rad((player.v - 0) + 0);
            dx = (speed * Math.cos(rads));
            dy = (speed * Math.sin(rads));

        }

        if (Key.isDown(Key.DOWN))
        {
            var rads = rad((player.v-0)+  0);
            dx = -(speed * Math.cos(rads));
            dy = -(speed * Math.sin(rads));
        }

        move_player(dx, dy);

    }


    var Key = {
        _pressed: {},

        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        MINUS: 189,
        PLUS: 187,

        isDown: function(keyCode) {
            return this._pressed[keyCode];
        },

        onKeydown: function(event) {
            this._pressed[event.keyCode] = true;
        },

        onKeyup: function(event) {
            delete this._pressed[event.keyCode];
        }
    };




    function rad(d) { return d * (Math.PI / 180); }
    function deg(r) { return r * (180 / Math.PI); }



    Initialise();


</script>
</html>

    

<!DOCTYPE html>
<html>
<head>
    <title>Portal/Sector Render</title>
    <script src="./util/util.js"></script>
    <script src="projection3d.js"></script>
    <script src="MapLoader.js"></script>


</head>
<body>


<canvas id="screen" width="320" height="240"
        style="border:1px solid #000000; float: left">
</canvas>

<div id="status" style="float: left; margin: 5px; font-family: Arial; font-size: 14px">tests</div>

<button type="button" onclick="Initialise()" style="display:none">Import</button>

</body>
<script>

    var SCREEN_WIDTH = 640;
    var SCREEN_HEIGHT = 480;
    var SCREEN_FOV = 60;

    document.getElementById('screen').width = SCREEN_WIDTH;
    document.getElementById('screen').height = SCREEN_HEIGHT;

    var buffer = document.getElementById('screen');
    var buffer_context = buffer.getContext('2d');
    var buffer_data = buffer_context.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    var fov = SCREEN_FOV;
    var vfov = deg(2 * Math.atan(Math.tan(rad(fov)/2) * (SCREEN_HEIGHT/SCREEN_WIDTH)));
    var projection_width = SCREEN_WIDTH;
    var projection_centre = projection_width / 2;
    var projection_height = SCREEN_HEIGHT;

    var focal_length = projection_centre / Math.tan(rad(fov/2));

    function PLAYER()
    {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.v = 0;
        this.height = 20;
        this.sector = 0;
    }

    var player  = new PLAYER();

    var Game = {};

    function Initialise()
    {
        Game.scene = new PerspectiveProjector(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_FOV);

        Game.map = new Map();
        Game.fps = 30;

        Game.map.load('./maps/alantest2.map', 0.025, function(){

            player.x = Game.map.player.start_x;
            player.y = Game.map.player.start_y;
            player.v = Game.map.player.start_ang;
            player.height = 25;
            player.sector = Game.map.player.start_sector;
            player.z = Game.map.player.start_z;

            window.addEventListener('keyup', function(event) {Key.onKeyup(event);}, false);
            window.addEventListener('keydown', function(event) {Key.onKeydown(event);}, false);

            Game.frameTimer = window.setInterval(Render, 1000 / Game.fps);

            Render();

        });

    }

    function Rotate2d(x, y, angle)
    {
        var rv = rad(angle);

        var s = Math.sin(rv);
        var c = Math.cos(rv);

        //var rx1 = x * Math.cos(rv) - y * Math.sin(rv);
        //var rz1 = y * Math.cos(rv) + x * Math.sin(rv);
        var rx = x * Math.sin(rv) - y * Math.cos(rv);
        var rz = x * Math.cos(rv) + y * Math.sin(rv);
        //var rx = x * c - y * s;
        //var rz = x * s + y * c;

        return {x: rx, z: rz};
    }

    function project_wall(sector_height, z)
    {
        var heightA = (sector_height / z) *  focal_length;
        var eyeHeight = player.height * 0.75;
        //var player_z = objectZ = 0;
        var base = (eyeHeight *2); // + player_z - objectZ) * 2;
        var horizonOffset = (heightA - Math.floor(base / z * focal_length)) / 2;
        var endA = parseInt((SCREEN_HEIGHT / 2 - horizonOffset) + heightA / 2);
        return {height: heightA, y_bottom: endA};
    }

    function cross(x1, y1, x2, y2)
    {
        return x1*y2 - y1*x2;
    }

    function intersect2(x1,y1, x2,y2, x3,y3, x4,y4)
    {
        var x = vxs(vxs(x1, y1, x2, y2),  (x1) - (x2), vxs(x3, y3, x4, y4), (x3) - (x4)) / vxs((x1) - (x2), (y1) - (y2), (x3) - (x4), (y3) - (y4));
        var y = vxs(vxs(x1, y1, x2, y2), (y1) - (y2), vxs(x3, y3, x4, y4), (y3) - (y4)) / vxs((x1) - (x2), (y1) - (y2), (x3) - (x4), (y3) - (y4));
        return {x: x, y: y};
;    }

    function intersect(x1, y1, x2, y2, x3, y3, x4, y4)
    {
        var x = cross(x1, y1, x2, y2);
        var y = cross(x3, y3, x4, y4);
        var det = cross(x1-x2, y1-y2, x3-x4, y3-y4);
        var cx = cross(x, x1-x2, y, x3-x4) / det;
        var cy = cross(x, y1-y2, y, y3-y4) / det;

        return {x: cx, y: cy};
    }

    function intersect_box(x0,y0, x1,y1, x2,y2, x3,y3)
    {
        return  (overlap(x0,x1,x2,x3) && overlap(y0,y1,y2,y3));
    }

    function overlap(a0,a1,b0,b1)
    {
        return (Math.min(a0,a1) <= Math.max(b0,b1) & Math.min(b0,b1) <= Math.max(a0,a1));
    }


    function point_side(px,py, x0,y0, x1,y1)
    {
        return vxs((x1)-(x0), (y1)-(y0), (px)-(x0), (py)-(y0));
    }

    function vxs(x0,y0, x1,y1)
    {
        return ((x0)*(y1) - (x1)*(y0));
    }

    function RenderSector2(sectorId)
    {
        var sector = Game.map.sectors[sectorId];

        for (var p=0; p<sector.walls.length; p++)
        {
            var wall = sector.walls[p];

            var wall_colour = '#aaaaaa';
            if (wall.portalTo != -1) wall_colour = '#ff0000';

            var vx1 = Game.map.vertices[wall.p1].x, vy1 = Game.map.vertices[wall.p1].y;
            var vx2 = Game.map.vertices[wall.p2].x, vy2 = Game.map.vertices[wall.p2].y;

            vx1 -= player.x; vy1 -= player.y;
            vx2 -= player.x; vy2 -= player.y;

            var r1 = Rotate2d(vx1, vy1, player.v);
            var r2 = Rotate2d(vx2, vy2, player.v);

            var sheight = sector.height;

            // completely off player's fov, move to next...
            if (r1.z <=0 && r2.z <=0) continue;

            var cp1 = intersect2(r1.x, r1.z, r2.x, r2.z, -0.0001, 0.0001, -20, 5);
            var cp2 = intersect2(r1.x, r1.z, r2.x, r2.z,  0.0001, 0.0001, 20, 5);

            if (r1.z <= 0.0001)
            {
                if (cp1.y > 0) {
                    r1.x = cp1.x;
                    r1.z = cp1.y;
                } else {
                    r1.x = cp2.x;
                    r1.z = cp2.y;
                }
            }

            if (r2.z <= 0.0001)
            {
                if (cp1.y > 0) {
                    r2.x = cp1.x;
                    r2.z = cp1.y;
                } else {
                    r2.x = cp2.x;
                    r2.z = cp2.y;
                }
            }

            var we = Game.scene.getEdge(player, r1, r2, sector.floor_height, sector.ceiling_height);

            if (wall.portalTo != -1)
            {
                var nextSector = Game.map.sectors[wall.portalTo];
                var portalEdge = Game.scene.projectPortalSector(we, r1, r2, nextSector.floor_height, nextSector.ceiling_height);
            }

            //vertical edge sides of wall
            line(we.x1, we.y1a, we.x1, we.y1b, wall_colour);
            line(we.x2, we.y2a, we.x2, we.y2b, wall_colour);

            //horz
            line(we.x1, we.y1a, we.x2, we.y2a, wall_colour);
            line(we.x1, we.y1b, we.x2, we.y2b, wall_colour);


            if (1 == 0) {
                var x1 = (-r1.x / r1.z) * focal_length;
                var x2 = (-r2.x / r2.z) * focal_length;

                var w_width = (x2 - x1) + 1;

                var y_bottom = edge1.y_bottom;
                var dy_bottom = (edge2.y_bottom - edge1.y_bottom) / w_width;

                var w_height = edge1.height;
                var dw_height = (edge2.height - edge1.height) / w_width;

                for (var wx = x1; wx < w_width; wx++) {
                    y_bottom += dy_bottom;
                    w_height += dw_height;
                }
                line(x1, edge1.y_bottom - edge1.height, x2, edge2.y_bottom - edge2.height,wall_colour);
                line(x1, edge1.y_bottom, x2, edge2.y_bottom,wall_colour);

                line(x2, edge2.y_bottom - edge2.height, x2, edge2.y_bottom,wall_colour);
                line(x1, edge1.y_bottom - edge1.height, x1, edge1.y_bottom,wall_colour);


                ///** WIREFRAME MODE -

                var steps = x2-x1;
                var ytop1 = edge2.y_bottom - edge2.height;
                var ybot1 = edge2.y_bottom;

                var ytop2 = edge1.y_bottom - edge1.height;
                var ybot2 = edge1.y_bottom;

                var ytopinc = (ytop2 - ytop1) / steps;
                var ybotinc = (ybot2 - ybot1) / steps;

                var ys = ytop1, ye = ybot1;

                for (var x=x1; x<x2; x++)
                {
                    //line (x, ys, x, ye, wall_colour);

                    ys += ytopinc;
                    ye += ybotinc;
                }
            }



        }

    }



    function Render()
    {
        move();

        buffer_context.clearRect(0,0,buffer.width, buffer.height);

        var sector = Game.map.sectors[player.sector];

        for (var s=0; s<sector.walls.length; s++)
        {
            if (sector.walls[s].portalTo > -1)
                RenderSector2(sector.walls[s].portalTo);
        }

        RenderSector2(player.sector);

        status();

    }


    function line(x1, y1, x2, y2, col)
    {
        if (!col) col = '#0000ff';
        buffer_context.beginPath();
        buffer_context.moveTo(x1, y1);
        buffer_context.lineTo(x2, y2);
        buffer_context.lineWidth = 1;
        buffer_context.strokeStyle = col;
        buffer_context.stroke();
    }

    function clamp(value, min, max)
    {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }


    function get_centre_of_sector(sec)
    {
        var sector = map.sectors[sec];

        var pts = [];

        for (var v=0; v<sector.vertices.length-1; v++)
            pts.push({x: map.vertices[sector.vertices[v]].x, y: map.vertices[sector.vertices[v]].y});

        return get_polygon_centroid(pts);

    }

    function get_polygon_centroid(pts) {
        var twicearea=0,
                x=0, y=0,
                nPts = pts.length,
                p1, p2, f;
        for ( var i=0, j=nPts-1 ; i<nPts ; j=i++ ) {
            p1 = pts[i]; p2 = pts[j];
            f = p1.x*p2.y - p2.x*p1.y;
            twicearea += f;
            x += ( p1.x + p2.x ) * f;
            y += ( p1.y + p2.y ) * f;
        }
        f = twicearea * 3;
        return { x:x/f, y:y/f };
    }


    function status_clear()
    {
        document.getElementById("status").innerHTML = "";
    }
    function status_write(text)
    {
        document.getElementById("status").innerHTML += text+"<br/>";
    }
    function status()
    {
        status_clear();

        status_write("<b>Player</b>");
        status_write("X: "+player.x.toFixed(2)+", Y: "+player.y.toFixed(2)+", Z: "+player.z);
        status_write("Angle: "+player.v.toFixed(2));
        status_write("Sector: "+player.sector);

        var sector = Game.map.sectors[player.sector];

        var psec = "";
        for (var t=0; t<sector.walls.length; t++)
        {
            var p = sector.walls[t].portalTo;
            if (p != -1) psec += p+",";
        }

        status_write("Potential visible sectors: "+psec);

    }

    function move_player(dx, dy)
    {
        var px = player.x, py = player.y;

        var sector = Game.map.sectors[player.sector];

        for (var s=0; s<sector.walls.length; s++)
        {
            var wall = sector.walls[s];

            if (wall.portalTo >= 0)
            {
                if (intersect_box(px, py, px+dx, py+dy,
                                Game.map.vertices[wall.p1].x, Game.map.vertices[wall.p1].y,
                                Game.map.vertices[wall.p2].x, Game.map.vertices[wall.p2].y))
                {
                    if (point_side(px+dx, py+dy,
                                    Game.map.vertices[wall.p1].x, Game.map.vertices[wall.p1].y,
                                    Game.map.vertices[wall.p2].x, Game.map.vertices[wall.p2].y))
                    {
                        player.sector = wall.portalTo;
                        break;

                    }

                }
            }

        }

        player.x += dx;
        player.y += dy;

    }


    function move()
    {
        var dx = 0, dy = 0;
        var speed =10;
/*
        if (e.keyCode == 189) // '-'
            player.height -=2;

        if (e.keyCode == 187) // '='
            player.height += 2;
*/
        if (Key.isDown(Key.RIGHT))
        {
            player.v +=6;
            if (player.v > 359) player.v -= 360;
        }

        if (Key.isDown(Key.LEFT))
        {
            player.v -= 6;
            if (player.v < 0) player.v += 360;
        }

        if (Key.isDown(Key.UP))
        {
            var rads = rad((player.v - 0) + 0);
            dx = (speed * Math.cos(rads));
            dy = (speed * Math.sin(rads));

        }

        if (Key.isDown(Key.DOWN))
        {
            var rads = rad((player.v-0)+  0);
            dx = -(speed * Math.cos(rads));
            dy = -(speed * Math.sin(rads));
        }

        move_player(dx, dy);

    }


    var Key = {
        _pressed: {},

        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,

        isDown: function(keyCode) {
            return this._pressed[keyCode];
        },

        onKeydown: function(event) {
            this._pressed[event.keyCode] = true;
        },

        onKeyup: function(event) {
            delete this._pressed[event.keyCode];
        }
    };




    function rad(d) { return d * (Math.PI / 180); }
    function deg(r) { return r * (180 / Math.PI); }



    Initialise();


</script>
</html>

    